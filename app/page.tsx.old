"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import Link from "next/link";

type Coords = { lat: number; lon: number };
type Prediction = { kind: "city" | "course"; placeId: string; description: string };


function verdictStyles(verdict?: string) {
  if (verdict === "GREEN") return { dot: "üü¢", pill: "bg-emerald-600", ring: "ring-emerald-200" };
  if (verdict === "YELLOW") return { dot: "üü°", pill: "bg-amber-500", ring: "ring-amber-200" };
  return { dot: "üî¥", pill: "bg-rose-600", ring: "ring-rose-200" };
}

function Chip({ children }: { children: React.ReactNode }) {
  return (
    <span className="inline-flex items-center rounded-full border border-white/10 bg-white/5 px-3 py-1 text-xs text-white/80">
      {children}
    </span>
  );
}

/* ---------- Greens firmness (today-only, v1.2-ish signal) ---------- */
function getNum(v: any): number | null {
  const n = typeof v === "number" ? v : Number(v);
  return Number.isFinite(n) ? n : null;
}


function asTimeLabel(v: any): string | null {
  if (v == null) return null;

  // Already a readable label like "7:12 AM" or "07:12"
  if (typeof v === "string") {
    const s = v.trim();
    if (!s) return null;

    // If it's an ISO string, try to format
    if (s.includes("T")) {
      const d = new Date(s);
      if (!Number.isNaN(d.getTime())) {
        return d.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
      }
    }

    // Otherwise assume it's already a label
    return s;
  }

  // Unix epoch seconds or ms
  if (typeof v === "number" && Number.isFinite(v)) {
    const ms = v > 1e12 ? v : v * 1000;
    const d = new Date(ms);
    if (!Number.isNaN(d.getTime())) {
      return d.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
    }
  }

  return null;
}


/* ---------- Yardage estimate (carry change) ---------- */
function estimateCarryChangeYards({
  tempC,
  verdict,
}: {
  tempC?: number | null;
  verdict?: "GREEN" | "YELLOW" | "RED" | string | null;
}): { minYds: number; maxYds: number } | null {
  // Don't show on RED days
  if (verdict === "RED") return null;

  const BASE_TEMP_C = 20;
  if (tempC == null) return null;

  const deltaC = tempC - BASE_TEMP_C;

  // Simple, golfer-friendly rule of thumb:
  // ~1‚Äì2 yards per 5¬∞C change in temperature (carry estimate).
  const a = (deltaC / 5) * 1;
  const b = (deltaC / 5) * 2;

  const r = (n: number) => Math.round(n);
  const minYds = r(Math.min(a, b));
  const maxYds = r(Math.max(a, b));

  // Hide tiny/noisy changes
  if (Math.max(Math.abs(minYds), Math.abs(maxYds)) < 2) return null;

  return { minYds, maxYds };
}

function computeGreensFirmness(weather: any) {
  const d0 = weather?.daily?.[0] ?? null;
  const d1 = weather?.daily?.[1] ?? null;
  const d2 = weather?.daily?.[2] ?? null;

  // --- Wet load (how much water is likely sitting in the surface/upper profile) ---
  // Providers vary in naming, so we defensively try a few.
  const p0 =
    getNum(d0?.precipMm) ??
    getNum(d0?.precipTotal) ??
    getNum(d0?.rainMm) ??
    getNum(d0?.precip) ??
    0;

  const p1 =
    getNum(d1?.precipMm) ??
    getNum(d1?.precipTotal) ??
    getNum(d1?.rainMm) ??
    getNum(d1?.precip) ??
    0;

  const p2 =
    getNum(d2?.precipMm) ??
    getNum(d2?.precipTotal) ??
    getNum(d2?.rainMm) ??
    getNum(d2?.precip) ??
    0;

  // Weighted: today matters most, tomorrow matters some (ongoing wetness),
  // day+2 is a light signal.
  const wetLoadMm = p0 + 0.5 * p1 + 0.25 * p2;

  // --- Drying power (sun/heat proxy + wind proxy) ---
  const nightLow =
    getNum(d0?.minTempC) ??
    getNum(d0?.tempMinC) ??
    getNum(d0?.minTemp) ??
    getNum(d0?.tempMin) ??
    null;

  const dayHigh =
    getNum(d0?.maxTempC) ??
    getNum(d0?.tempMaxC) ??
    getNum(d0?.maxTemp) ??
    getNum(d0?.tempMax) ??
    null;

  const windKph =
    getNum(weather?.current?.windKph) ??
    getNum(d0?.windKph) ??
    getNum(d0?.windMaxKph) ??
    getNum(d0?.windMax) ??
    null;

  // Heat drying: 0 at 10C, ramps to ~1 at 20C, ~1.5 at 28C+
  const heatDry =
    dayHigh == null ? 0 : Math.max(0, Math.min(1.5, (dayHigh - 10) / 12));
  // Wind drying: 0 at 5kph, ramps to ~1 at 25kph+
  const windDry =
    windKph == null ? 0 : Math.max(0, Math.min(1.0, (windKph - 5) / 20));
  const dryingPower = heatDry + windDry;

  // Cold/clammy mornings stay softer longer (dew + slow evap)
  const coldPenalty = nightLow != null && nightLow <= 3 ? 0.5 : 0;

  // Softness index: higher = softer, lower = firmer
  // Scale wet load so ~10mm feels meaningfully soft unless dryingPower is high.
  const softnessIndex = wetLoadMm / 6 + coldPenalty - dryingPower;

  // Edge case: near/below freezing tends to be firm/frozen early.
  if (dayHigh != null && nightLow != null && nightLow <= -1 && dayHigh <= 2) {
    return {
      key: "FIRM",
      label: "Greens: üî¥ Firm",
      detail: "Cold/frozen surfaces possible early (check for frost delays)",
    };
  }

  if (softnessIndex >= 2.0) {
    return {
      key: "SOFT",
      label: "Greens: üü¢ Soft",
      detail: "Approaches should hold (more moisture)",
    };
  }
  if (softnessIndex <= 0.4) {
    return {
      key: "FIRM",
      label: "Greens: üî¥ Firm",
      detail: "Some bounce & rollout ‚Äî plan for release",
    };
  }
  return {
    key: "NORMAL",
    label: "Greens: üü° Normal",
    detail: "Typical bounce & rollout",
  };
}

/** v1.1: Courses ‚Äî curate the list (less is more) */
function scoreCourse(c: any) {
  // Higher is better
  const rating = typeof c?.rating === "number" ? c.rating : 0;
  const ratingsCount = typeof c?.userRatingsTotal === "number" ? c.userRatingsTotal : 0;

  // Prefer open-now slightly
  const openBoost = c?.openNow === true ? 20 : c?.openNow === false ? -10 : 0;

  // Weak signal: more ratings = more trustworthy, capped
  const countBoost = Math.min(10, Math.floor(ratingsCount / 50)); // caps at +10

  return rating * 10 + countBoost + openBoost;
}

function pickTopCourses(all: any[], limit = 4) {
  return [...all]
    .filter((c) => c?.mapsUrl) // only actionable
    .sort((a, b) => scoreCourse(b) - scoreCourse(a))
    .slice(0, limit);
}

function CourseCard({ c }: { c: any }) {
  const ratingText =
    typeof c?.rating === "number"
      ? `‚≠ê ${c.rating.toFixed(1)}${c?.userRatingsTotal ? ` (${c.userRatingsTotal})` : ""}`
      : "No rating yet";

  const openText = c?.openNow === true ? "Open now" : c?.openNow === false ? "Closed" : null;

  return (
    <a
      href={c.mapsUrl || "#"}
      target="_blank"
      rel="noreferrer"
      className="group rounded-3xl border border-white/10 bg-white/5 p-5 transition hover:bg-white/10"
    >
      <div className="flex items-start justify-between gap-4">
        <div className="min-w-0">
          <div className="flex flex-wrap items-center gap-x-3 gap-y-2">
            <div className="truncate text-base font-semibold">{c.name}</div>

            <div className="inline-flex items-center gap-2">
              <span className="rounded-full bg-white/10 px-2.5 py-1 text-xs text-white/80">
                {ratingText}
              </span>

              {openText && (
                <span className="rounded-full bg-white/10 px-2.5 py-1 text-xs text-white/70">
                  {openText}
                </span>
              )}
            </div>
          </div>

          {c.address && <div className="mt-2 line-clamp-2 text-sm text-white/65">{c.address}</div>}

          <div className="mt-4 text-sm text-white/70">Tap to open directions</div>
        </div>

        <div className="rounded-2xl bg-white/10 px-3 py-2 text-xs font-semibold text-white/80 group-hover:bg-white/15">
          Maps ‚Üí
        </div>
      </div>
    </a>
  );
}

export default function HomePage() {
  const [coords, setCoords] = useState<Coords | null>(null);
  const [geoErr, setGeoErr] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const [weather, setWeather] = useState<any>(null);
  const [courses, setCourses] = useState<any>(null);
  const [simulators, setSimulators] = useState<any>(null);

  // City search
  const [cityQuery, setCityQuery] = useState("");
  const [predictions, setPredictions] = useState<Prediction[]>([]);
  const [searching, setSearching] = useState(false);
  const boxRef = useRef<HTMLDivElement | null>(null);

  // Selected day (0..4)
  const [selectedDay, setSelectedDay] = useState<number>(0);

  // Optional tee time ("HH:MM")
  const [teeTime, setTeeTime] = useState<string>("");

  // v1.1: ‚ÄúShow all courses‚Äù toggle
  const [showAllCourses, setShowAllCourses] = useState(false);

  // One-time query param bootstrap (supports landing pages like /city/toronto)
  const didBootstrapFromQuery = useRef(false);

  useEffect(() => {
    if (didBootstrapFromQuery.current) return;
    if (typeof window === "undefined") return;

    const q = new URLSearchParams(window.location.search).get("q");
    if (!q) return;

    didBootstrapFromQuery.current = true;

    const label = q.replace(/[-_]+/g, " ").trim();
    if (label && !cityQuery) setCityQuery(label);

    (async () => {
      try {
        const sres = await fetch(`/api/location/suggest?q=${encodeURIComponent(label)}`);
        const sdata = await sres.json();
        const preds = Array.isArray(sdata?.predictions) ? sdata.predictions : [];
        const first = preds[0];
        if (!first?.placeId) return;

        const rres = await fetch(`/api/location/resolve?placeId=${encodeURIComponent(first.placeId)}`);
        const rdata = await rres.json();
        if (rdata?.coords?.lat && rdata?.coords?.lon) {
          setCoords({ lat: rdata.coords.lat, lon: rdata.coords.lon });
          if (rdata?.label) setCityQuery(rdata.label);
          setSelectedDay(0);
        }
      } catch {
        // silent
      }
    })();
  }, [cityQuery]);

  const selectedDaily = useMemo(() => weather?.daily?.[selectedDay] ?? null, [weather, selectedDay]);

  const teeTimeResult = useMemo(() => {
    if (!teeTime || !selectedDaily?.blocks) return null;

    const [hh, mm] = teeTime.split(":").map((n) => Number(n));
    if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;

    const targetMinutes = hh * 60 + mm;
    const blocks = selectedDaily.blocks as any[];

    let best: any = null;
    let bestDelta = Infinity;

    for (const b of blocks) {
      const d = new Date(b.dt * 1000);
      const m = d.getHours() * 60 + d.getMinutes();
      const delta = Math.abs(m - targetMinutes);
      if (delta < bestDelta) {
        bestDelta = delta;
        best = b;
      }
    }

    if (!best) return null;

    return {
      ...best,
      deltaMinutes: bestDelta,
    };
  }, [teeTime, selectedDaily]);

  const showVerdict =
    teeTimeResult?.verdict ?? selectedDaily?.golf?.verdict ?? weather?.golf?.verdict ?? null;

  const verdictLabel = useMemo(() => {
    const v = showVerdict;
    if (!v) return null;
    if (v === "GREEN") return "Green light";
    if (v === "YELLOW") return "Playable";
    return "Not golfable";
  }, [showVerdict]);

  // --- Share summary ---
  const [copied, setCopied] = useState(false);
  useEffect(() => {
    if (!copied) return;
    const t = setTimeout(() => setCopied(false), 1200);
    return () => clearTimeout(t);
  }, [copied]);

  const windSummaryText = useMemo(() => {
    if (selectedDay === 0) {
      const w = weather?.current?.windKph;
      const g = weather?.current?.gustKph;
      if (w == null) return null;
      return `${w} km/h${g != null ? ` (gust ${g})` : ""}`;
    }
    const w = selectedDaily?.windMax ?? selectedDaily?.windKph ?? null;
    const g = selectedDaily?.gustMax ?? selectedDaily?.gustKph ?? null;
    if (w == null) return null;
    return `${w} km/h${g != null ? ` (gust ${g})` : ""}`;
  }, [selectedDay, selectedDaily, weather]);

  const greensBadgeText = useMemo(() => {
    const g = selectedDay === 0 ? weather?.ground?.greensSpeed?.label : selectedDaily?.ground?.greensSpeed?.label;
    return g ? String(g).replace(/^Greens speed:\s*/i, "") : null;
  }, [selectedDay, selectedDaily, weather]);

  const rolloutBadgeText = useMemo(() => {
    const r = selectedDay === 0 ? weather?.ground?.fairwayRollout?.label : selectedDaily?.ground?.fairwayRollout?.label;
    return r ? String(r).replace(/^Fairway rollout:\s*/i, "") : null;
  }, [selectedDay, selectedDaily, weather]);

  const bestWindowText = useMemo(() => {
  const tzOffsetSec = typeof weather?.tzOffsetSec === "number" ? weather.tzOffsetSec : 0;

  // Format a unix dt in the destination/course timezone (not the viewer's browser timezone).
  const fmt = (dtSec: number) =>
    new Date((dtSec + tzOffsetSec) * 1000).toLocaleTimeString([], {
      hour: "numeric",
      minute: "2-digit",
      hour12: true,
      timeZone: "UTC",
    });

  const isToday = selectedDay === 0;

  // Resolve blocks for the chosen day.
  let rawBlocks: any = isToday ? (weather?.bestTime?.byTime ?? weather?.bestTime?.blocks ?? weather?.bestTime?.byHour ?? null) : (selectedDaily?.blocks ?? null);
  if (rawBlocks && !Array.isArray(rawBlocks) && typeof rawBlocks === "object") rawBlocks = Object.values(rawBlocks);
  const blocks: any[] = Array.isArray(rawBlocks) ? rawBlocks : [];

  // Sunrise/sunset bounds for TODAY (destination).
  const sunriseDt = isToday && typeof weather?.daylight?.sunrise === "number" ? weather.daylight.sunrise : null;
  const sunsetDt = isToday && typeof weather?.daylight?.sunset === "number" ? weather.daylight.sunset : null;

  const daylightStart = sunriseDt != null ? sunriseDt + 60 * 60 : null; // 1h after sunrise
  const latestStart = sunsetDt != null ? sunsetDt - 3 * 60 * 60 : null;   // so 3h window ends by sunset

  // Extract bestWindow from API (schema-tolerant).
  const apiBw: any = isToday ? (weather?.bestTime?.bestWindow ?? null) : (selectedDaily?.bestWindow ?? null);

  const labelStart: string | null =
    (typeof apiBw?.startLabel === "string" ? apiBw.startLabel : null) ??
    (typeof apiBw?.start === "string" ? apiBw.start : null) ??
    null;

  const labelEnd: string | null =
    (typeof apiBw?.endLabel === "string" ? apiBw.endLabel : null) ??
    (typeof apiBw?.end === "string" ? apiBw.end : null) ??
    null;

  const startDtFromApi: number | null =
    (typeof apiBw?.startDt === "number" ? apiBw.startDt : null) ??
    (typeof apiBw?.start === "number" ? apiBw.start : null) ??
    null;

  const endDtFromApi: number | null =
    (typeof apiBw?.endDt === "number" ? apiBw.endDt : null) ??
    (typeof apiBw?.end === "number" ? apiBw.end : null) ??
    null;

  const avgFromApi: number | null =
    typeof apiBw?.avgScore === "number" ? apiBw.avgScore : (typeof apiBw?.avg === "number" ? apiBw.avg : null);

  // Helper: validate a candidate start dt against golfing hours + daylight.
  const isValidStart = (dt: number) => {
    if (isToday) {
      if (daylightStart != null && dt < daylightStart) return false;
      if (latestStart != null && dt > latestStart) return false;
      // golfing hours in destination local time: 6am‚Äì3pm starts
      const hr = new Date((dt + tzOffsetSec) * 1000).getUTCHours();
      if (hr < 6 || hr > 15) return false;
      if (sunsetDt != null && dt >= sunsetDt) return false;
    }
    return true;
  };

  // 1) Try to resolve startDt/endDt from API window.
  let startDt: number | null = startDtFromApi;
  if (startDt == null && labelStart && blocks.length > 0) {
    const b = blocks.find((x: any) => typeof x?.dt === "number" && (x?.label === labelStart));
    if (typeof b?.dt === "number") startDt = b.dt;
  }

  let endDt: number | null = endDtFromApi;
  if (startDt != null && endDt == null) endDt = startDt + 3 * 60 * 60;

  // 2) If missing or invalid (TODAY), derive from blocks using destination sunrise/sunset + golfing hours.
  if ((startDt == null || !isValidStart(startDt)) && blocks.length > 0) {
    const pool = blocks
      .filter((b: any) => typeof b?.dt === "number" && typeof b?.score === "number")
      .filter((b: any) => b?.inDaylight !== false)
      .filter((b: any) => isValidStart(b.dt));

    const best = pool.reduce((acc: any, b: any) => (!acc || b.score > acc.score ? b : acc), null);

    if (best && typeof best.dt === "number") {
      startDt = best.dt;
      endDt = best.dt + 3 * 60 * 60;
    } else {
      // No valid pool -> nothing to show
      return null;
    }
  }

  if (startDt == null || endDt == null) return null;

  // Clamp end to sunset for TODAY
  if (isToday && sunsetDt != null) {
    endDt = Math.min(endDt, sunsetDt);
    if (startDt >= sunsetDt) return null;
  }

  const startStr = fmt(startDt);
  const endStr = fmt(endDt);

  // Prefer API avgScore; otherwise use the start block score if available.
  let avg = avgFromApi;
  if (avg == null && blocks.length > 0) {
    const b = blocks.find((x: any) => typeof x?.dt === "number" && x.dt === startDt && typeof x?.score === "number");
    if (typeof b?.score === "number") avg = b.score;
  }

  const avgSuffix = typeof avg === "number" ? ` (avg ${Math.round(avg)}/100)` : "";
  return `${startStr} ‚Äì ${endStr}${avgSuffix}`;
}, [selectedDaily, selectedDay, weather]);

const shareText = useMemo(() => {
    const score = teeTimeResult?.score ?? selectedDaily?.golf?.score ?? weather?.golf?.score ?? null;
    const verdict = verdictLabel ?? "Golf forecast";
    const where = cityQuery?.trim() ? cityQuery.trim() : "your area";
    const parts = [
      `${verdict}${score != null ? ` (${score}/100)` : ""} ‚Äî ${where}`,
      bestWindowText ? `Best window: ${bestWindowText}` : null,
      windSummaryText ? `Wind: ${windSummaryText}` : null,
      greensBadgeText ? `Greens: ${greensBadgeText}` : null,
      rolloutBadgeText ? `Rollout: ${rolloutBadgeText}` : null,
      `CanIGolfToday.com`,
    ].filter(Boolean);
    return parts.join(" ‚Ä¢ ");
  }, [teeTimeResult, selectedDaily, weather, verdictLabel, cityQuery, bestWindowText, windSummaryText, greensBadgeText, rolloutBadgeText]);




  const carryChange = useMemo(() => {
    if (showVerdict === "RED") return null;

    // Prefer day-specific values; fall back to current conditions for today
    const t =
      selectedDay === 0
        ? getNum(weather?.current?.temp) ?? getNum(weather?.current?.feels) ?? null
        : getNum(selectedDaily?.maxTemp) ?? getNum(selectedDaily?.max) ?? null;

    return estimateCarryChangeYards({ tempC: t, verdict: showVerdict });
  }, [showVerdict, selectedDay, selectedDaily, weather]);

  const carryChangeText = useMemo(() => {
    if (!carryChange) return null;
    const min = carryChange.minYds;
    const max = carryChange.maxYds;

    const fmt = (n: number) => `${n > 0 ? "+" : ""}${n}`;
    if (min === max) return `${fmt(min)} yds`;
    return `${fmt(min)} to ${fmt(max)} yds`;
  }, [carryChange]);
  
  const bestWindowRange = useMemo(() => {
  const tzOffsetSec = typeof weather?.tzOffsetSec === "number" ? weather.tzOffsetSec : 0;
  const isToday = selectedDay === 0;

  let rawBlocks: any = isToday ? (weather?.bestTime?.byTime ?? weather?.bestTime?.blocks ?? weather?.bestTime?.byHour ?? null) : (selectedDaily?.blocks ?? null);
  if (rawBlocks && !Array.isArray(rawBlocks) && typeof rawBlocks === "object") rawBlocks = Object.values(rawBlocks);
  const blocks: any[] = Array.isArray(rawBlocks) ? rawBlocks : [];

  const sunriseDt = isToday && typeof weather?.daylight?.sunrise === "number" ? weather.daylight.sunrise : null;
  const sunsetDt = isToday && typeof weather?.daylight?.sunset === "number" ? weather.daylight.sunset : null;

  const daylightStart = sunriseDt != null ? sunriseDt + 60 * 60 : null;
  const latestStart = sunsetDt != null ? sunsetDt - 3 * 60 * 60 : null;

  const apiBw: any = isToday ? (weather?.bestTime?.bestWindow ?? null) : (selectedDaily?.bestWindow ?? null);

  const labelStart: string | null =
    (typeof apiBw?.startLabel === "string" ? apiBw.startLabel : null) ??
    (typeof apiBw?.start === "string" ? apiBw.start : null) ??
    null;

  const startDtFromApi: number | null =
    (typeof apiBw?.startDt === "number" ? apiBw.startDt : null) ??
    (typeof apiBw?.start === "number" ? apiBw.start : null) ??
    null;

  const endDtFromApi: number | null =
    (typeof apiBw?.endDt === "number" ? apiBw.endDt : null) ??
    (typeof apiBw?.end === "number" ? apiBw.end : null) ??
    null;

  const isValidStart = (dt: number) => {
    if (isToday) {
      if (daylightStart != null && dt < daylightStart) return false;
      if (latestStart != null && dt > latestStart) return false;
      const hr = new Date((dt + tzOffsetSec) * 1000).getUTCHours();
      if (hr < 6 || hr > 15) return false;
      if (sunsetDt != null && dt >= sunsetDt) return false;
    }
    return true;
  };

  let startDt: number | null = startDtFromApi;
  if (startDt == null && labelStart && blocks.length > 0) {
    const b = blocks.find((x: any) => typeof x?.dt === "number" && x?.label === labelStart);
    if (typeof b?.dt === "number") startDt = b.dt;
  }

  let endDt: number | null = endDtFromApi;
  if (startDt != null && endDt == null) endDt = startDt + 3 * 60 * 60;

  if ((startDt == null || !isValidStart(startDt)) && blocks.length > 0) {
    const pool = blocks
      .filter((b: any) => typeof b?.dt === "number" && typeof b?.score === "number")
      .filter((b: any) => b?.inDaylight !== false)
      .filter((b: any) => isValidStart(b.dt));

    const best = pool.reduce((acc: any, b: any) => (!acc || b.score > acc.score ? b : acc), null);

    if (best && typeof best.dt === "number") {
      startDt = best.dt;
      endDt = best.dt + 3 * 60 * 60;
    } else {
      return null;
    }
  }

  if (startDt == null || endDt == null) return null;

  if (isToday && sunsetDt != null) {
    endDt = Math.min(endDt, sunsetDt);
    if (startDt >= sunsetDt) return null;
  }

  return { startDt, endDt };
}, [selectedDaily?.bestWindow, selectedDaily?.blocks, selectedDay, weather?.bestTime?.bestWindow, weather?.bestTime?.byTime, weather?.bestTime?.blocks, weather?.bestTime?.byHour, weather?.daylight?.sunrise, weather?.daylight?.sunset, weather?.tzOffsetSec]);




const sunriseSunsetText = useMemo(() => {
  const sunrise =
    weather?.daylight?.sunriseLabel ??
    (weather?.daylight?.sunrise
      ? new Date(weather.daylight.sunrise * 1000).toLocaleTimeString([], {
          hour: "numeric",
          minute: "2-digit",
        })
      : null);

  const sunset =
    weather?.daylight?.sunsetLabel ??
    (weather?.daylight?.sunset
      ? new Date(weather.daylight.sunset * 1000).toLocaleTimeString([], {
          hour: "numeric",
          minute: "2-digit",
        })
      : null);

  if (!sunrise && !sunset) return null;
  if (sunrise && sunset) return `Sunrise ${sunrise} ‚Ä¢ Sunset ${sunset}`;
  if (sunrise) return `Sunrise ${sunrise}`;
  return `Sunset ${sunset}`;
}, [weather?.daylight]);



  // Ground / greens signals (computed server-side using recent precip history where available)
  // For future days, we use a forecast-based proxy included in each day object.
  const selectedGround = (selectedDay === 0 ? weather?.ground : selectedDaily?.ground) ?? null;
  const greensSpeed = selectedGround?.greensSpeed ?? null;
  const fairwayRollout = selectedGround?.fairwayRollout ?? null;

// How the day plays out (golfer-first): Morning vs Midday vs Late.
// IMPORTANT: "today" data sometimes lives under weather.bestTime.byTime rather than daily[0].blocks,
// so we fall back to those sources.
const playOut = useMemo(() => {
  const WINDOW_SEC = 3 * 60 * 60;

  // 1) Get blocks from the selected day; for today, fall back to bestTime blocks/byTime.
  let raw: any = selectedDaily?.blocks ?? null;

  if ((!Array.isArray(raw) || raw.length === 0) && selectedDay === 0) {
    raw = weather?.bestTime?.byTime ?? weather?.bestTime?.blocks ?? weather?.bestTime?.byHour ?? null;
    // If API returns an object-map, normalize to array
    if (raw && !Array.isArray(raw) && typeof raw === "object") raw = Object.values(raw);
  }

  if (!Array.isArray(raw) || raw.length === 0) return null as null | any;

  const sorted = [...raw]
    .filter((b: any) => typeof b?.dt === "number" && typeof b?.score === "number")
    .sort((a: any, b: any) => (a?.dt ?? 0) - (b?.dt ?? 0));

  if (sorted.length === 0) return null;

  // 2) For today, clamp to daylight explicitly (no after-sunset blocks).
  const sunriseDt =
    selectedDay === 0 && typeof weather?.daylight?.sunrise === "number"
      ? weather.daylight.sunrise
      : null;

  const sunsetDt =
    selectedDay === 0 && typeof weather?.daylight?.sunset === "number"
      ? weather.daylight.sunset
      : null;

  const daylight = (sunriseDt != null || sunsetDt != null)
    ? sorted.filter((b: any) => {
        if (sunriseDt != null && b.dt < sunriseDt) return false;
        if (sunsetDt != null && b.dt >= sunsetDt) return false;
        return true;
      })
    : sorted;

  const pool = daylight.length > 0 ? daylight : sorted;

  // 3) Derive day bounds.
  const inferredStart = pool[0].dt;
  const inferredEnd = pool[pool.length - 1].dt + 60 * 60; // hourly-ish
  const dayStart = sunriseDt != null ? Math.max(inferredStart, sunriseDt) : inferredStart;
  const dayEnd = sunsetDt != null ? Math.min(inferredEnd, sunsetDt) : inferredEnd;

  // 4) Utility: average score in range (returns null if no blocks).
  const avgInRange = (startDt: number, endDt: number) => {
    const xs = pool
      .filter((b: any) => b.dt >= startDt && b.dt < endDt)
      .map((b: any) => b.score);
    if (xs.length === 0) return null;
    const avg = xs.reduce((a: number, n: number) => a + n, 0) / xs.length;
    return Math.round(avg);
  };

  const allAvg = (() => {
    const xs = pool.map((b: any) => b.score);
    if (xs.length === 0) return 0;
    return Math.round(xs.reduce((a: number, n: number) => a + n, 0) / xs.length);
  })();

  // 5) Bucket boundaries (local-time hours):
  // Morning: 6‚Äì11, Midday: 11‚Äì15, Late: 15‚Äìsunset (daylight filtered when available).
  const tzOffsetSec = typeof (weather as any)?.tzOffsetSec === "number" ? (weather as any).tzOffsetSec : 0;
  const localHour = (dt: number) => new Date((dt + tzOffsetSec) * 1000).getUTCHours();

  const daylightForBuckets = (() => {
    const xs = pool.filter((b: any) => b?.inDaylight !== false);
    return xs.length > 0 ? xs : pool;
  })();

  const avgByHourRange = (hStart: number, hEnd: number) => {
    const xs = daylightForBuckets
      .filter((b: any) => {
        if (typeof b?.dt !== "number") return false;
        const h = localHour(b.dt);
        return h >= hStart && h < hEnd;
      })
      .map((b: any) => b.score);
    if (xs.length === 0) return null;
    const avg = xs.reduce((a: number, n: number) => a + n, 0) / xs.length;
    return Math.round(avg);
  };

  const morningScore = avgByHourRange(6, 11);
  const middayScore = avgByHourRange(11, 15);
  const lateScore = avgByHourRange(15, 24);

  // Never show blanks: fall back to overall avg if a bucket has no blocks.
  const ms = morningScore ?? allAvg;
  const mds = middayScore ?? allAvg;
  const ls = lateScore ?? allAvg;

  const toVerdict = (score: number) => {
    if (score >= 80) return "GREEN";
    if (score >= 60) return "YELLOW";
    return "RED";
  };

  // 6) Decide which bucket contains the best tee-time window start (authoritative).
  let bestBucket: "morning" | "midday" | "late" | null = null;
  const bwStart = bestWindowRange?.startDt ?? null;

  if (typeof bwStart === "number") {
    const h = localHour(bwStart);
    if (h < 11) bestBucket = "morning";
    else if (h < 15) bestBucket = "midday";
    else bestBucket = "late";
  } else {
    // fallback: highest scoring bucket
    const best = [
      { k: "morning" as const, s: ms },
      { k: "midday" as const, s: mds },
      { k: "late" as const, s: ls },
    ].sort((a, b) => b.s - a.s)[0];
    bestBucket = best?.k ?? null;
  }
return {
    bestBucket,
    segments: [
      { key: "morning", label: "Morning", score: ms, verdict: toVerdict(ms) },
      { key: "midday", label: "Midday", score: mds, verdict: toVerdict(mds) },
      { key: "late", label: "Late", score: ls, verdict: toVerdict(ls) },
    ],
    range: { startDt: dayStart, endDt: dayEnd },
  };
}, [
  selectedDaily?.blocks,
  selectedDay,
  weather?.bestTime,
  weather?.daylight?.sunrise,
  weather?.daylight?.sunset,
  bestWindowRange?.startDt,
  bestWindowRange?.endDt,
]);


  const showScore = teeTimeResult?.score ?? selectedDaily?.golf?.score ?? weather?.golf?.score;
  const showReason = teeTimeResult?.reason ?? selectedDaily?.golf?.reason ?? weather?.golf?.reason;

  const style = verdictStyles(showVerdict || "RED");

  const confidenceLine = useMemo(() => {
    const v = showVerdict;
    if (v === "GREEN") return "Book it with confidence.";
    if (v === "YELLOW") return "Playable if you catch the window.";
    if (v === "RED") return "Courses are likely closed or unpleasant.";
    return null;
  }, [showVerdict]);

  const redReasonChips = useMemo(() => {
    if (showVerdict !== "RED") return [];

    const chips: { label: string; weight: number }[] = [];

    const tempC =
      (typeof teeTimeResult?.temp === "number" ? teeTimeResult.temp : null) ??
      (selectedDay === 0 ? weather?.current?.temp : null) ??
      null;

    const windKph =
      (typeof teeTimeResult?.windKph === "number" ? teeTimeResult.windKph : null) ??
      (selectedDay === 0 ? weather?.current?.windKph : null) ??
      (typeof selectedDaily?.windMax === "number" ? selectedDaily.windMax : null) ??
      null;

    const conditions =
      teeTimeResult?.conditions ??
      (selectedDay === 0 ? weather?.current?.conditions : selectedDaily?.conditions) ??
      null;

    const precipMm =
      (typeof teeTimeResult?.precipMm === "number" ? teeTimeResult.precipMm : null) ?? null;

    if (typeof tempC === "number") {
      if (tempC <= 2) chips.push({ label: "‚ùÑÔ∏è Too cold", weight: 100 });
      else if (tempC <= 6) chips.push({ label: "ü•∂ Cold", weight: 70 });
    }

    if (typeof windKph === "number") {
      if (windKph >= 35) chips.push({ label: "üå¨ Very windy", weight: 90 });
      else if (windKph >= 25) chips.push({ label: "üå¨ Windy", weight: 65 });
    }

    const cond = typeof conditions === "string" ? conditions.toLowerCase() : "";
    const precipy =
      (typeof precipMm === "number" && precipMm > 0) ||
      cond.includes("rain") ||
      cond.includes("drizzle") ||
      cond.includes("thunder") ||
      cond.includes("snow");

    if (precipy) {
      if (cond.includes("snow")) chips.push({ label: "üå® Snow", weight: 95 });
      else chips.push({ label: "üåß Wet", weight: 80 });
    }

    if (teeTime && teeTimeResult && teeTimeResult.inDaylight === false) {
      chips.push({ label: "üåô Low light", weight: 60 });
    }

    if (chips.length === 0) chips.push({ label: "üö´ Poor conditions", weight: 50 });

    return chips
      .sort((a, b) => b.weight - a.weight)
      .slice(0, 3)
      .map((c) => c.label);
  }, [showVerdict, teeTime, teeTimeResult, selectedDay, selectedDaily, weather]);

  async function loadAll(c: Coords) {
    setLoading(true);
    setGeoErr(null);

    const [w, cs] = await Promise.all([
      fetch(`/api/weather?lat=${c.lat}&lon=${c.lon}`).then((r) => r.json()),
      fetch(`/api/courses?lat=${c.lat}&lon=${c.lon}`).then((r) => r.json()),
    ]);

    setWeather(w);
    setCourses(cs);

    setSelectedDay(0);
    setTeeTime("");
    setShowAllCourses(false);

    const day0Verdict = w?.daily?.[0]?.golf?.verdict ?? w?.golf?.verdict;
    if (day0Verdict === "RED") {
      const sims = await fetch(`/api/simulators?lat=${c.lat}&lon=${c.lon}`).then((r) => r.json());
      setSimulators(sims);
    } else {
      setSimulators(null);
    }

    setLoading(false);
  }

  useEffect(() => {
    setTeeTime("");
  }, [selectedDay]);

  useEffect(() => {
    async function maybeLoadSims() {
      if (!coords || !weather?.daily) return;
      const v = weather?.daily?.[selectedDay]?.golf?.verdict;
      if (v === "RED") {
        const sims = await fetch(`/api/simulators?lat=${coords.lat}&lon=${coords.lon}`).then((r) =>
          r.json()
        );
        setSimulators(sims);
      } else {
        setSimulators(null);
      }
    }
    maybeLoadSims();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedDay]);

  function useMyLocation() {
    if (!navigator.geolocation) {
      setGeoErr("Geolocation not supported in this browser.");
      return;
    }

    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const c = { lat: pos.coords.latitude, lon: pos.coords.longitude };
        setCoords(c);
        loadAll(c);
      },
      (err) => setGeoErr(err.message || "Couldn‚Äôt get your location."),
      { enableHighAccuracy: true, timeout: 10000 }
    );
  }

  useEffect(() => {
    const q = cityQuery.trim();
    if (q.length < 2) {
      setPredictions([]);
      return;
    }
    const t = setTimeout(async () => {
      try {
        setSearching(true);
        const res = await fetch(`/api/location/suggest?q=${encodeURIComponent(q)}`);
        const data = await res.json();
        setPredictions(Array.isArray(data?.predictions) ? data.predictions : []);
      } catch {
        setPredictions([]);
      } finally {
        setSearching(false);
      }
    }, 250);

    return () => clearTimeout(t);
  }, [cityQuery]);

  useEffect(() => {
    function onClick(e: MouseEvent) {
      if (!boxRef.current) return;
      if (!boxRef.current.contains(e.target as Node)) setPredictions([]);
    }
    window.addEventListener("mousedown", onClick);
    return () => window.removeEventListener("mousedown", onClick);
  }, []);

  async function choosePrediction(p: Prediction) {
    try {
      setPredictions([]);
      setGeoErr(null);
      setLoading(true);

      const res = await fetch(`/api/location/resolve?placeId=${encodeURIComponent(p.placeId)}`);
      const data = await res.json();

      if (!res.ok || !Number.isFinite(data?.lat) || !Number.isFinite(data?.lon)) {
        setGeoErr(data?.error || "Couldn‚Äôt resolve that city.");
        setLoading(false);
        return;
      }

      setCityQuery(data?.address || p.description);

      const c = { lat: Number(data.lat), lon: Number(data.lon) };
      setCoords(c);
      await loadAll(c);
    } catch {
      setGeoErr("Couldn‚Äôt resolve that city.");
      setLoading(false);
    }
  }

  /** v1.1: curated courses */
  const allCourses = Array.isArray(courses?.courses) ? courses.courses : [];
  const topCourses = useMemo(() => pickTopCourses(allCourses, 4), [allCourses]);

  const showSims = Array.isArray(simulators?.simulators) ? simulators.simulators : [];

  const restCourses = useMemo(() => {
    if (!allCourses.length) return [];
    if (!topCourses.length) return allCourses;
    const topIds = new Set(topCourses.map((t: any) => t.placeId));
    return allCourses.filter((c: any) => !topIds.has(c.placeId));
  }, [allCourses, topCourses]);

  return (
    <main className="min-h-screen bg-[#0b0f14] text-white">
      <div className="relative">
        <div
          className="absolute inset-0 bg-cover bg-center opacity-35"
          style={{
            backgroundImage:
              "url(https://images.unsplash.com/photo-1520975958225-6b8b2b8d2c1c?auto=format&fit=crop&w=2400&q=80)",
          }}
        />
        <div className="absolute inset-0 bg-gradient-to-b from-black/70 via-black/50 to-[#0b0f14]" />

        <div className="relative mx-auto max-w-5xl px-6 pb-10 pt-10">
		{/* About button ‚Äì safe, non-intrusive */}
  <div className="absolute right-6 top-6 z-50">
    <Link
      href="/about"
      className="rounded-2xl bg-white/10 px-4 py-2 text-sm font-semibold text-white/90 ring-1 ring-white/10 hover:bg-white/15 transition"
    >
      About
    </Link>
  </div>
          <div className="flex flex-col gap-6 md:flex-row md:items-end md:justify-between">
            <div className="max-w-2xl">
              <div className="inline-flex items-center gap-2 rounded-full bg-white/10 px-3 py-1 text-xs text-white/80">
                ‚õ≥ CanIGolfToday.com
              </div>

              <h1 className="mt-4 text-4xl font-semibold tracking-tight md:text-5xl">
                Your tee-time forecast.
              </h1>
              <p className="mt-3 text-white/75">
                Search a city or course ‚Äî we‚Äôll score the conditions and find the best 3‚Äëhour daylight window.
              </p>
            </div>

            <div className="flex flex-wrap gap-3">
              <button
                onClick={useMyLocation}
                className="rounded-2xl bg-white px-4 py-2 text-sm font-semibold text-black hover:opacity-90"
              >
                Use my location
              </button>
              {coords && (
                <div className="rounded-2xl bg-white/10 px-4 py-2 text-sm text-white/80">
                  {coords.lat.toFixed(3)}, {coords.lon.toFixed(3)}
                </div>
              )}
            </div>
          </div>

          <section className="mt-8" ref={boxRef}>
            <div className="relative">
              <input
                value={cityQuery}
                onChange={(e) => setCityQuery(e.target.value)}
                placeholder="Search city or course: Guelph, Toronto, Glen Abbey‚Ä¶"
                className="w-full rounded-2xl border border-white/10 bg-white/10 px-4 py-3 text-sm text-white placeholder:text-white/50 outline-none focus:border-white/25"
              />

              {predictions.length > 0 && (
                <div className="absolute z-20 mt-2 w-full overflow-hidden rounded-2xl border border-white/10 bg-[#0f1620] shadow-xl">
                  {predictions.map((p) => (
                    <button
                      key={p.placeId}
                      onClick={() => choosePrediction(p)}
                      className="block w-full px-4 py-3 text-left text-sm text-white/90 hover:bg-white/5"
                    >
                      {p.description}
                    </button>
                  ))}
                </div>
              )}

              {searching && <div className="mt-2 text-xs text-white/60">Searching‚Ä¶</div>}

            {/* Quick picks + secondary actions */}
            <div className="mt-4 flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
              <div className="flex flex-wrap gap-2">
                {["Toronto", "Myrtle Beach", "Scottsdale", "Pebble Beach", "Cabot Cliffs"].map((label) => {
                  const slug = label.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");
                  return (
                    <Link
                      key={label}
                      href={`/city/${slug}`}
                      className="rounded-full bg-white/10 px-3 py-1.5 text-xs font-semibold text-white/80 ring-1 ring-white/10 hover:bg-white/15"
                      onClick={() => setCityQuery(label)}
                    >
                      {label}
                    </Link>
                  );
                })}
              </div>

              <div className="flex items-center gap-3">
                <button
                  type="button"
                  onClick={useMyLocation}
                  className="rounded-2xl bg-white/10 px-4 py-2 text-sm font-semibold text-white/90 ring-1 ring-white/10 hover:bg-white/15 transition"
                >
                  Use my location
                </button>

                {coords && (
                  <div className="rounded-2xl bg-white/5 px-4 py-2 text-sm text-white/70 ring-1 ring-white/10">
                    {coords.lat.toFixed(3)}, {coords.lon.toFixed(3)}
                  </div>
                )}
              </div>
            </div>

            <div className="mt-3 text-xs text-white/50">
              Built for quick decisions ‚Äî not perfect predictions. Always check course openings + frost delays.
            </div>
            </div>

            {geoErr && (
              <div className="mt-3 rounded-2xl bg-rose-500/15 p-3 text-sm text-rose-200">
                {geoErr}
              </div>
            )}
          </section>
        </div>
      </div>

      <div className="mx-auto max-w-5xl px-6 pb-16 pt-8">
        {!loading && !(weather?.golf || selectedDaily?.golf) && (
          <section className="grid gap-4 md:grid-cols-3">
            <div className="rounded-3xl bg-white/5 p-5 ring-1 ring-white/10">
              <div className="text-sm font-semibold text-white/90">How it works</div>
              <div className="mt-2 text-sm text-white/70">
                We score temperature, wind, precipitation, and daylight to find the best golf window.
              </div>
            </div>

            <div className="rounded-3xl bg-white/5 p-5 ring-1 ring-white/10">
              <div className="text-sm font-semibold text-white/90">What the score means</div>
              <div className="mt-2 text-sm text-white/70">
                Green = ideal. Yellow = playable tradeoffs. Red = tough conditions.
              </div>
            </div>

            <div className="rounded-3xl bg-white/5 p-5 ring-1 ring-white/10">
              <div className="text-sm font-semibold text-white/90">Why it‚Äôs simple</div>
              <div className="mt-2 text-sm text-white/70">
                No forecasts overload ‚Äî just a clear ‚Äúshould I book?‚Äù
              </div>
            </div>
          </section>
        )}
        {loading && <div className="text-white/70">Loading‚Ä¶</div>}

        {(weather?.golf || selectedDaily?.golf) && (
          <section className={`rounded-3xl bg-white/5 p-6 shadow-sm ring-1 ${style.ring}`}>
            <div className="flex flex-col gap-6 md:flex-row md:items-start md:justify-between">
              <div className="min-w-0">
                <div className="flex items-center gap-3">
                  <div
                    className={`h-10 w-10 rounded-2xl ${style.pill} grid place-items-center text-lg`}
                  >
                    {style.dot}
                  </div>
                  <div>
                    <div className="text-2xl font-semibold">{verdictLabel}</div>
                    <div className="mt-1 text-sm text-white/70">
                      Score: <span className="font-semibold text-white">{showScore}</span>/100 ‚Äî{" "}
                      {showReason}
                    </div>

                    {confidenceLine && (
                      <div className="mt-2 text-sm text-white/80">{confidenceLine}</div>
                    )}

                    {showVerdict === "RED" && redReasonChips.length > 0 && (
                      <div className="mt-3 flex flex-wrap gap-2">
                        {redReasonChips.map((c) => (
                          <Chip key={c}>{c}</Chip>
                        ))}
                      </div>
                    )}
                  </div>
                </div>

                
{(bestWindowText || sunriseSunsetText) && (
  <div className="mt-4 inline-flex flex-wrap items-center gap-x-3 gap-y-1 rounded-2xl bg-white/10 px-4 py-2 text-sm text-white/85">
    {bestWindowText && (
      <>
        <span className="text-white/70">Best tee-time window</span>
        <span className="font-semibold">{bestWindowText}</span>
      </>
    )}
    {sunriseSunsetText && (
      <span className="text-white/60">{sunriseSunsetText}</span>
    )}

<button
  type="button"
  onClick={async () => {
    try {
      await navigator.clipboard.writeText(shareText);
      setCopied(true);
    } catch {
      // no-op
    }
  }}
  className="ml-1 inline-flex items-center rounded-full border border-white/10 bg-white/5 px-3 py-1 text-xs font-semibold text-white/80 hover:bg-white/10"
  title="Copy a shareable summary"
>
  {copied ? "Copied" : "Share"}
</button>

  </div>
)}

                
                {showVerdict !== "RED" && (
                  <div className="mt-4 rounded-2xl bg-white/5 p-4 ring-1 ring-white/10">
                    <div className="text-sm font-semibold text-white/90">How the day plays out</div>

                    <ul className="mt-3 space-y-2 text-sm text-white/80">
                      <li>
                        <span className="font-semibold text-white/90">Morning</span> ‚Äî{" "}
                        {(() => {
                          const s = playOut?.segments?.find((x: any) => x.key === "morning")?.score;
                          if (playOut?.bestBucket === "morning") {
                            return <span className="font-semibold text-emerald-300">Best window</span>;
                          }
                          if (s == null) return "‚Äî";
                          return s >= 80 ? "Excellent" : s >= 60 ? "Decent" : "Challenging";
                        })()}
                      </li>

                      <li>
                        <span className="font-semibold text-white/90">Midday</span> ‚Äî{" "}
                        {(() => {
                          const s = playOut?.segments?.find((x: any) => x.key === "midday")?.score;
                          if (playOut?.bestBucket === "midday") {
                            return <span className="font-semibold text-emerald-300">Best window</span>;
                          }
                          if (s == null) return "‚Äî";
                          return s >= 80 ? "Excellent" : s >= 60 ? "Decent" : "Challenging";
                        })()}
                      </li>

                      <li>
                        <span className="font-semibold text-white/90">Late</span> ‚Äî{" "}
                        {(() => {
                          const s = playOut?.segments?.find((x: any) => x.key === "late")?.score;
                          if (playOut?.bestBucket === "late") {
                            return <span className="font-semibold text-emerald-300">Best window</span>;
                          }
                          if (s == null) return "‚Äî";
                          return s >= 65 ? "Holds up" : "Falls off";
                        })()}
                      </li>
                    </ul>
                  </div>
                )}

                {showVerdict !== "RED" && (greensSpeed || fairwayRollout) && (
                  <div className="mt-4 grid gap-3 md:grid-cols-2">
                    {greensSpeed && (
                      <div className="rounded-2xl bg-white/10 p-4 ring-1 ring-white/10">
                        <div className="flex items-start justify-between gap-3">
                          <div className="text-sm font-semibold text-white/90">Greens speed</div>
                          <span className="inline-flex items-center rounded-full bg-white/10 px-2.5 py-1 text-xs font-semibold text-white/85">
                            {String(greensSpeed.label).replace(/^Greens speed:\s*/i, "")}
                          </span>
                        </div>
                        <div className="mt-1 text-sm text-white/70">{greensSpeed.detail}</div>
                      </div>
                    )}

                    {fairwayRollout && (
                      <div className="rounded-2xl bg-white/10 p-4 ring-1 ring-white/10">
                        <div className="flex items-start justify-between gap-3">
                          <div className="text-sm font-semibold text-white/90">Fairway rollout</div>
                          <span className="inline-flex items-center rounded-full bg-white/10 px-2.5 py-1 text-xs font-semibold text-white/85">
                            {String(fairwayRollout.label).replace(/^Fairway rollout:\s*/i, "")}
                          </span>
                        </div>
                        <div className="mt-1 text-sm text-white/70">{fairwayRollout.detail}</div>
                      </div>
                    )}

                    {(selectedGround?.past48hPrecipMm != null || selectedGround?.past24hPrecipMm != null) && (
                      <div className="md:col-span-2 text-xs text-white/55">
                        Recent precip: {selectedGround?.past24hPrecipMm ?? "‚Äî"}mm (24h) ¬∑ {selectedGround?.past48hPrecipMm ?? "‚Äî"}mm (48h)
                      </div>
                    )}

                    {selectedGround?.forecast48hWetnessMm != null && (
                      <div className="md:col-span-2 text-xs text-white/55">
                        Wetness proxy: {selectedGround.forecast48hWetnessMm}mm (prior 48h forecast window)
                      </div>
                    )}
                  </div>
                )}

                <div className="mt-4 flex flex-wrap items-center gap-3">
                  <div className="text-sm text-white/70">Tee time (optional)</div>

                  <input
                    type="time"
                    value={teeTime}
                    onChange={(e) => setTeeTime(e.target.value)}
                    className="rounded-2xl border border-white/10 bg-white/10 px-3 py-2 text-sm text-white outline-none focus:border-white/25"
                  />

                  {teeTimeResult && (
                    <div className="rounded-2xl bg-white/10 px-4 py-2 text-sm text-white/85">
                      <span className="text-white/60">At {teeTime}:</span>{" "}
                      <span className="font-semibold">{teeTimeResult.score}/100</span>{" "}
                      <span className="text-white/60">
                        (wind {teeTimeResult.windKph}k, {teeTimeResult.conditions})
                      </span>
                    </div>
                  )}

                  {teeTime && (
                    <button
                      onClick={() => setTeeTime("")}
                      className="text-sm text-white/60 underline decoration-white/30 hover:text-white"
                    >
                      clear
                    </button>
                  )}
                </div>

                {Array.isArray(weather?.daily) && weather.daily.length > 0 && (
                  <div className="mt-5">
                    <div className="text-xs font-semibold text-white/60">Next 5 days</div>
                    <div className="mt-3 flex flex-wrap gap-2">
                      {weather.daily.slice(0, 5).map((d: any, idx: number) => {
                        const v = d?.golf?.verdict;
                        const dot = v === "GREEN" ? "üü¢" : v === "YELLOW" ? "üü°" : "üî¥";
                        const active = idx === selectedDay;

                        const dayGreens = d?.ground?.greensSpeed?.label
                          ? String(d.ground.greensSpeed.label).replace(/^Greens speed:\s*/i, "")
                          : null;
                        const dayRoll = d?.ground?.fairwayRollout?.label
                          ? String(d.ground.fairwayRollout.label).replace(/^Fairway rollout:\s*/i, "")
                          : null;

                        return (
                          <button
                            key={d.dateKey || idx}
                            onClick={() => setSelectedDay(idx)}
                            className={[
                              "rounded-2xl border px-4 py-3 text-left text-sm transition",
                              active
                                ? "border-white/30 bg-white/10"
                                : "border-white/10 bg-white/5 hover:bg-white/10",
                            ].join(" ")}
                          >
                            <div className="flex items-center gap-2">
                              <span>{dot}</span>
                              <span className="font-semibold">{d.dayLabel}</span>
                            </div>
                            <div className="mt-1 text-xs text-white/65">
                              {d.maxTemp ?? "‚Äî"}¬∞ / {d.minTemp ?? "‚Äî"}¬∞ ¬∑ wind{" "}
                              {d.windMax ?? "‚Äî"}k
                              <span className="text-white/50"> (gust {d.gustMax ?? "‚Äî"}k)</span>
                            </div>

                            {v === "YELLOW" && (dayGreens || dayRoll) && (
                              <div className="mt-1 text-xs text-white/55">
                                {dayGreens ? `Greens ${dayGreens}` : ""}
                                {dayGreens && dayRoll ? " ¬∑ " : ""}
                                {dayRoll ? `Rollout ${dayRoll}` : ""}
                              </div>
                            )}
                          </button>
                        );
                      })}
                    </div>
                  </div>
                )}
              </div>

              <div className="rounded-3xl bg-white/5 p-5 text-sm text-white/80 ring-1 ring-white/10 md:min-w-[280px]">
                {selectedDay === 0 ? (
                  <>
                    <div className="flex justify-between gap-6">
                      <span className="text-white/60">Temp</span>
                      <span>
                        {weather?.current?.temp ?? "‚Äî"}¬∞C{" "}
                        <span className="text-white/50">
                          (feels {weather?.current?.feels ?? "‚Äî"}¬∞C)
                        </span>
                      </span>
                    </div>
                    <div className="mt-2 flex justify-between gap-6">
                      <span className="text-white/60">Wind</span>
                      <span>
                        {weather?.current?.windKph ?? "‚Äî"} km/h{" "}
                        <span className="text-white/50">
                          (gust {weather?.current?.gustKph ?? "‚Äî"})
                        </span>
                      </span>
                    </div>

                    {carryChangeText && (
                      <div className="mt-2 flex justify-between gap-6">
                        <span className="text-white/60">Carry change</span>
                        <span>{carryChangeText}</span>
                      </div>
                    )}

                    {weather?.current?.conditions && (
                      <div className="mt-2 flex justify-between gap-6">
                        <span className="text-white/60">Conditions</span>
                        <span>{weather.current.conditions}</span>
                      </div>
                    )}
                  </>
                ) : (
                  <>
                    <div className="flex justify-between gap-6">
                      <span className="text-white/60">High / Low</span>
                      <span>
                        {selectedDaily?.maxTemp ?? "‚Äî"}¬∞ / {selectedDaily?.minTemp ?? "‚Äî"}¬∞
                      </span>
                    </div>
                    <div className="mt-2 flex justify-between gap-6">
                      <span className="text-white/60">Max wind</span>
                      <span>
                        {selectedDaily?.windMax ?? "‚Äî"} km/h
                        <span className="text-white/50"> (gust {selectedDaily?.gustMax ?? "‚Äî"})</span>
                      </span>
                    </div>

                    {carryChangeText && (
                      <div className="mt-2 flex justify-between gap-6">
                        <span className="text-white/60">Carry change</span>
                        <span>{carryChangeText}</span>
                      </div>
                    )}

                    {selectedDaily?.conditions && (
                      <div className="mt-2 flex justify-between gap-6">
                        <span className="text-white/60">Conditions</span>
                        <span>{selectedDaily.conditions}</span>
                      </div>
                    )}
                  </>
                )}
              </div>
            </div>
          </section>
        )}

        {/* v1.1: curated ‚ÄúTop picks near you‚Äù + expandable full list */}
        {(topCourses.length > 0 || allCourses.length > 0) && (
          <section className="mt-8">
            <div className="flex items-end justify-between gap-6">
              <div>
                <h2 className="text-xl font-semibold">Top picks near you</h2>
                <div className="mt-1 text-sm text-white/60">
                  Curated by rating + ‚Äúopen now‚Äù (quick list ‚Äî not a directory).
                </div>
              </div>

              <div className="text-sm text-white/60">
                {showVerdict === "RED" ? "Likely closed (try sims)" : "Tap for directions"}
              </div>
            </div>

            {topCourses.length > 0 ? (
              <div className="mt-4 grid gap-3 md:grid-cols-2">
                {topCourses.map((c: any) => (
                  <CourseCard key={c.placeId} c={c} />
                ))}
              </div>
            ) : (
              <div className="mt-4 rounded-2xl border border-white/10 bg-white/5 p-4 text-sm text-white/70">
                No top picks found nearby.
              </div>
            )}

            {allCourses.length > 0 && (
              <div className="mt-5 flex flex-col items-start gap-3">
                <button
                  onClick={() => setShowAllCourses((v) => !v)}
                  className="rounded-2xl border border-white/10 bg-white/5 px-4 py-2 text-sm font-semibold text-white/85 hover:bg-white/10"
                >
                  {showAllCourses ? "Hide all courses" : `Show all ${allCourses.length} courses`}
                </button>

                {showAllCourses && (
                  <div className="w-full">
                    <div className="mb-3 text-sm text-white/60">All nearby courses</div>
                    <div className="grid gap-3 md:grid-cols-2">
                      {restCourses.map((c: any) => (
                        <CourseCard key={c.placeId} c={c} />
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
          </section>
        )}

        {showVerdict === "RED" && showSims.length > 0 && (
          <section className="mt-8">
            <div className="flex items-end justify-between gap-6">
              <h2 className="text-xl font-semibold">Indoor golf / simulators</h2>
              <div className="text-sm text-white/60">Because it‚Äôs a red day outside.</div>
            </div>

            <div className="mt-4 grid gap-3 md:grid-cols-2">
              {showSims.map((s: any) => (
                <a
                  key={s.placeId}
                  href={s.mapsUrl || "#"}
                  target="_blank"
                  rel="noreferrer"
                  className="group rounded-3xl border border-white/10 bg-white/5 p-5 transition hover:bg-white/10"
                >
                  <div className="flex items-start justify-between gap-4">
                    <div className="min-w-0">
                      <div className="truncate text-base font-semibold">{s.name}</div>
                      <div className="mt-1 line-clamp-2 text-sm text-white/65">{s.address ?? ""}</div>
                      <div className="mt-3 text-sm text-white/80">
                        {s.rating ? `‚≠ê ${s.rating} (${s.userRatingsTotal ?? 0})` : "No rating yet"}
                        {s.openNow === true ? " ¬∑ Open now" : s.openNow === false ? " ¬∑ Closed" : ""}
                      </div>
                    </div>
                    <div className="rounded-2xl bg-white/10 px-3 py-2 text-xs text-white/70 group-hover:bg-white/15">
                      View
                    </div>
                  </div>
                </a>
              ))}
            </div>
          </section>
        )}

        <div className="mt-14 text-center text-xs text-white/45">
          Built for quick decisions ‚Äî not perfect predictions. Always check course openings + frost delays.
        </div>
      </div>
    </main>
  );
}
